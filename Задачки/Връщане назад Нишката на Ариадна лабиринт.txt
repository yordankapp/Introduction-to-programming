Връщане назад : Нишката на Ариадна

Лабиринтът ще представим като двумерен масив labyrinth от символи, които имат
следното значение:
‘ ‘ <интервал> - проходима област (коридор);
‘-‘ - непроходима област;
‘М’ - Минотавър.
Със символа ‘.’ ще маркираме изминатия път.
При движението ще спазваме следните правила:
1. “Входът” на лабиринта е клетката с координати (1; 1).
2. Можем да се придвижваме с една клетка във вертикално или хоризонтално
направление.
3. Можем да се придвижваме само към проходима клетка (‘ ‘) или към
Минотавъра (‘М’).
4. Не можем да напускаме очертанията на лабиринта.
След приключване на одисеята на екрана трябва да се изобрази целия лабиринт и
следата, оставена от нишката (със символа ‘.’).

За решаване на задачата ще използваме търсене с връщане назад по следния начин:
1. Ако сме в клетката с Минотавъра, задачата е решена
2. Ако сме в проходима клетка, маркираме я с ‘,’ и пробваме да продължим първо
надясно, при неуспех – нагоре, наляво и надолу, като проверяваме дали
съответната клетка е проходима.
3. Ако и четирите опита са неуспешни, връщаме се върху предходната клетка като
заменяме символа ‘.’ с ‘х’. Знакът ‘х’ ще означава, че този вариант вече е
проверен и няма смисъл отново да го пробваме. На клетките, означени с ‘х’ ще
гледаме като на непроходими клетки – това ще ни спаси от зацикляне.
Преди извеждане на лабиринта ще заменим всички символи ‘х’ с ‘ ‘.
Съставни структури от данни
104
Ще дефинираме рекурсивна функция FindPath(int x, int y, int found), където x и y са
координатите на текущата клетка, а found ще има стойност 1 (истина), ако пътят до
Минотавъра е открит и 0 (лъжа) – в противен случай. В зависимост от нея ще решаваме
дали да пробваме алтернативни варианти или не.
Както и при задачата за областите, за да елиминираме частните случаи,
предварително ще оградим лабиринта в рамка от непроходими клетки.


#include<iostream>
using namespace std;

const int MAX_ROWS=22, //От потребителя може да се дефинира
        MAX_COLS=22; //област с максимум 20 реда и 20 колони
char labyrinth[MAX_ROWS][MAX_COLS]; //Масивът, съхраняващ лабиринта
//е глобален
void InitLab(int& rows, int& cols);
//Инициализира лабиринт с rows реда и
//cols колони
void FindPath(int x, int y, int& found);
//Намира пътя от клетка (x,y) до Минотавъра
void PrintLab(int rows, int cols);
//Извежда лабиринта като при това заменя
//символа 'x' с '.'
int main()
{
    int rows, cols,
            found = 0; //Първоначално приемаме, че път
//не е намерен
    InitLab(rows, cols);
    FindPath(1, 1, found);
    cout << endl << "Нишката на Ариадна :\n";
    PrintLab(rows, cols);
    return 0;
}
void InitLab(int& rows, int& cols)
{
    int i,j;
    char ch;
    cout << "Въведете размерите на лабиринта - \n"
         << "до 20 реда и 20 колони\n";
    cout << "Редове :"; cin >> rows;
    cout << "Колони :"; cin >> cols;
    cout << "Въведете лабиринта :\n";
    for (i = 0; i <= rows+1; i++) //Поставяне на рамка
    {
        labyrinth[i][0] = '-';
        labyrinth[i][cols+1] = '-';
    }
    for (j = 0; j <= cols+1; j++) //Поставяне на рамка
    {
        labyrinth[0][j] = '-';
        labyrinth[rows+1][j] = '-';
    }
    cin.get(ch); //Прескачане на симвала '\n'
    for (i = 1; i <= rows; i++)
    {
        for (j = 1; j <= cols; j++)
            cin.get(labyrinth[i][j]);
        cin.get(ch); //Прескачане на символа '\n'
    }
}
void FindPath(int x, int y, int& found)
{
    if (labyrinth[x][y] == 'M')
    {
        found = 1;
        return;
    }
    labyrinth[x][y] = '.';
    if (!found && (labyrinth[x][y+1] == ' ' || labyrinth[x][y+1] == 'M'))
        FindPath(x, y+1, found); //Стъпка надясно
    if (!found && (labyrinth[x-1][y] == ' ' || labyrinth[x-1][y] == 'M'))
        FindPath(x-1, y, found); //Стъпка нагоре
    if (!found && (labyrinth[x][y-1] == ' ' || labyrinth[x][y-1] == 'M'))
        FindPath(x, y-1, found); //Стъпка наляво
    if (!found && (labyrinth[x+1][y] == ' ' || labyrinth[x+1][y] == 'M'))
        FindPath(x+1, y, found); //Стъпка надолу
    if (!found) //Клетката е проверена и от нея
        labyrinth[x][y] = 'x'; //няма път до Минотавъра
}
void PrintLab(int rows, int cols)
{
    for (int i = 1; i <= rows; i++)
    {
        for (int j = 1; j <= cols; j++)
        {
            if (labyrinth[i][j] == 'x') labyrinth[i][j] = ' ';
            cout << labyrinth[i][j];
        }
        cout << endl;
    }
}
